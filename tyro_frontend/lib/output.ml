(*
This module is responsible for all of the postprocessing after constraint
generation, up through actually outputting the constraints.

This includes enumerating locations and printing the output file.
*)

(* Note: [Implicit Location Chains]
A future re-evaluation of the implementation strategy might indicate that, for performance
or some other reason, ZGen should emit the entire constraint tree and not just the
constraints. Currently, we leave reconstructing the tree to the z3ml backend.

The idea is that we know the _program_ tree just from inspecting the intervals. Given,
for example, a tree like
          0
        /   \
       1     2
      / \   / \
     3   4 5   6

Then when we see a constraint file like
2 A(x,y,z)  <--- the location here cuts off chains for below; which is to say
             --- we follow them up their locations up the tree up to (but not incl.)
             --- the location given here.
  5 x = int <--- so this will just be 5 => x = int, without a 2=> in front.
  6 y = z
---
2 A(a,b,c)          <--- this constraint is generated by the let expression
1 A(int, bool, int) <--- this constraint is generated by a use of the bound var
3 w = int           <--- these two are just random examples
4 int = w

Then we generate the constraint SMT file of (pseudocode)
def A(x,y,z):
  5 => x = int   <--- 
  && 6 => y = z
0 => (1 => (A(int, bool, int)
            && 3 => w = int
            && 4 => int = w)
     && 2 => A(a,b,c))

Notice how the shape of the implications follows the paths through the tree.

This information can also be found in z3ml's README.
*)

(* default hash is fine. *)

open Ezy.EzyOcamlmodules
open Ezy.EzyConstraints
open Ezy.EzyTypingCoreTypes

module RenumberLocs = struct

  module H = Hashtbl

  type enumeration = (Location.t, int) Hashtbl.t

  let loc_of_constraint c = c.AtConstr.loc

  let locs_of_map m = ExtLocationMap.keys m

  (* don't need the scheme's loc itself because it's a map key too *)
  let locs_of_scheme Scheme.{cstrs ; _} = locs_of_map cstrs

  let locs_of_elt AtConstrSet.MainType.{schemes ; _} =
    let folder s = ExtLocationMap.KeySet.union (locs_of_scheme s) in
    AtConstrSet.SimpleSchemeSet.fold folder schemes ExtLocationMap.KeySet.empty

  let lookup (l : ExtLocation.t) (tbl : enumeration) =
    match l with
    | ExtLocation.Interface _ -> failwith "Looking up interface location?"
    | ExtLocation.Source l -> H.find tbl l

  let number_all_locs (cs : AtConstrSet.t) =
    let table  = H.create 16 (* same as zenv, idk *)
    and n      = ref 0 in

    let number_loc loc =
      match H.find_opt table loc with
      | Some v -> v
      | None   ->
        let v = !n in
        H.add table loc v;
        incr n;
        v
    in 

    let all_locs = 
      let open ExtLocationMap.KeySet in
      let map_folder loc elt acc =
        big_union [singleton loc; locs_of_elt elt; acc]
      in
      let all = ExtLocationMap.fold map_folder cs empty in
      let set_folder loc acc = match loc with
        | ExtLocation.Interface _ -> acc 
        | ExtLocation.Source loc -> loc :: acc
      in
      fold set_folder all []
    in

    List.iter (fun l -> let _ = number_loc l in ()) all_locs;
    table
end

(* Module for encapsulating the enumeration table => output process *)
module EmitEnumeration = struct

  (* Postprocess the enumeration table, mainly extracting the enumeration
     and sorting it. *)
  let postprocess (tbl : RenumberLocs.enumeration) =
    let s = Hashtbl.to_seq tbl in
    let l = List.of_seq s in
    List.fast_sort (fun (_, n) (_, m) -> compare n m) l

  let print_pos fmt (pos : Lexing.position) =
    Format.pp_print_int fmt pos.pos_lnum;
    Format.pp_print_char fmt ';';
    Format.pp_print_int fmt @@ pos.pos_cnum - pos.pos_bol + 1

  let print_pairing fmt ((loc : Location.t), n) =
    Format.pp_print_int fmt n;
    Format.pp_print_char fmt ' ';
    print_pos fmt loc.loc_start;
    Format.pp_print_char fmt '-';
    print_pos fmt loc.loc_end;
    if is_loc_hard (ExtLocation.Source loc) then begin
      Format.pp_print_char fmt ' ';
      Format.pp_print_int fmt 0;
    end;
    Format.pp_print_char fmt ';';
    Format.pp_print_newline fmt ()

  let f fmt tbl = postprocess tbl |> List.iter (print_pairing fmt)
end

module EmitConstraints = struct

  let f fmt ?(tbl=Hashtbl.create 0) cs =
    (* For debugging the type synonym hashtable *)
    (*begin 
      Hashtbl.iter (fun n _ -> print_string n; print_newline ()) Ezy.EzyGenerate.type_synonyms
    end;*)
    let open AtConstr in
    let get l = RenumberLocs.lookup l tbl in
    let pc (c : t) =
      match c with
      | { loc ; kind = EqC { tys = l,r ; _ } } ->
        Format.fprintf fmt "@\n%d %a = %a" (get loc) Ty.print l Ty.print r
      | { loc ; kind = SchemeC { name ; ivars ; _ } } ->
        Format.fprintf fmt "@\n%d %s(%a)"
          (get loc)
          name
          (Ezy.EzyUtils.List.print TyVar.print ",") ivars
    in
    AtConstrSet.SimpleAtConstrSet.iter pc cs

end

module EmitSchemes = struct

  let scm_cs (cstrs : AtConstrSet.SimpleAtConstrSet.t ExtLocationMap.t) =
    let open AtConstrSet.SimpleAtConstrSet in
    let folder _ = union in
    ExtLocationMap.fold folder cstrs empty

  let f fmt ?(tbl=Hashtbl.create 0) ss =
    let get l = RenumberLocs.lookup l tbl in
    let ps Scheme.{ name ; qvars ; cstrs ; loc ; _ } =
      Format.fprintf fmt "@[<v 2>%d %s(%a) {%a@]@\n}@\n"
        (get loc)
        name
        (Ezy.EzyUtils.List.print TyVar.print ",") qvars
        (EmitConstraints.f ~tbl) (scm_cs cstrs)
    in
    AtConstrSet.SimpleSchemeSet.iter ps ss

end

let do_output ?(fmt=Format.std_formatter) (cs : AtConstrSet.t) =
  let tbl = RenumberLocs.number_all_locs cs in
  let ss = AtConstrSet.all_schemes cs in
  let cs = AtConstrSet.all_constraints cs in
  Format.pp_open_vbox fmt 0;
  EmitEnumeration.f fmt tbl;
  Format.pp_print_string fmt "---";
  Format.pp_print_newline fmt ();
  EmitSchemes.f ~tbl fmt ss;
  Format.pp_print_string fmt "---";
  EmitConstraints.f ~tbl fmt cs; (* starts with @\n *)
  Format.pp_close_box fmt ()
